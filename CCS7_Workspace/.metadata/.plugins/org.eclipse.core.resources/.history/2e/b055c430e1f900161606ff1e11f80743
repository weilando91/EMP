/*****************************************************************************
* University of Southern Denmark
* Embedded Programming (EMP)
*
* MODULENAME.: main.c
*
* PROJECT....: Assignment1
*
* DESCRIPTION: None (no .h file)
*
* Change Log:
*****************************************************************************
* Date    Id                Change
* YYMMDD
* --------------------
* 150204  CP, TL, TJ, VT    Module created and structure planned
* 150211  CP, TL, TJ, VT    Module coded based on structure
* 150213  CP, TL, TJ, VT    Debugging and completion
*****************************************************************************/

/***************************** Include files *******************************/
#include <stdint.h>
#include "tm4c123gh6pm.h"
#include "emp_type.h"
/*****************************    Defines    *******************************/
/**** Timer time settings ****/
#define FCPU                 16000000 / 4   // Hz
#define TIMEOUT              1              // mS
#define SYSTICK_RELOAD_VALUE (( FCPU / 1000 ) * TIMEOUT) - 1 // Definition of formula
#if (SYSTICK_RELOAD_VALUE > 0x00FFFFFF)
    #error "Systick timer reload value to high"
#endif
/*****************************   Variables   *******************************/
INT8U    counter;                     // 8 bit value (256) for value for LED
INT8U    button_debounce_counter;     // 8 bit value (256) for debounce counter (detection)
INT16U   button_double_click_counter; // 16 bit (65.536) for double click counter (detection)
INT16U   button_automode_counter;     // 16 bit (65.536) for auto mode counter (enable)
BOOLEAN  automode;                    // Boolean for automode
INT8U    automode_counter;            // 8 bit value (256) for counting 200ms in automode
BOOLEAN  button_pressed;              // Boolean for button pressed

/*****************************   Functions   *******************************/
void enable_global_int()
/*****************************************************************************
*   Input    : None
*   Output   : None
*   Function : Global interrupt enable
******************************************************************************/
{
  __asm("cpsie i");
}

void disable_global_int()
/*****************************************************************************
*   Input    : None
*   Output   : None
*   Function : Global interrupt disable
******************************************************************************/
{
  __asm("cpsid i");
}

void setup_systick()
/*****************************************************************************
*   Input    : None
*   Output   : None
*   Function : Setup systick timer
******************************************************************************/
{
  NVIC_ST_RELOAD_R = SYSTICK_RELOAD_VALUE;      // Set reload register to calculated time value
  NVIC_ST_CURRENT_R = SYSTICK_RELOAD_VALUE;     // Clear current timer value
  NVIC_ST_CTRL_R |= 0x03;                       // 0b0011: Disable systick, enable interrupt, precision clock (16Mhz/4)

  NVIC_EN0_R |= 0x8000;                         // Enable systick interrupt vector number 15
  NVIC_UNPEND0_R |= 0x8000;                     // Clear pending interrupt
  NVIC_PRI0_R |= 0x30000000;                    // Set interrupt 15 to priority 3
}

void setup_io()
/*****************************************************************************
*   Input    : None
*   Output   : None
*   Function : Setup I/O
******************************************************************************/
{
  SYSCTL_RCGC2_R |= SYSCTL_RCGC2_GPIOF;     // Enables clock for GPIOF
  GPIO_PORTF_DIR_R |= 0x0E;                 // Set PF1(red),PF2(blue),PF3(green) to output, and PF4(Switch) to Input
  GPIO_PORTF_DEN_R |= 0x1E;                 // Digital Enable PF1,PF2,PF3,PF4
  GPIO_PORTF_PUR_R |= 0x10;                 // Enable Pull-up resistor on PF4 (switch)
}

void switch_color(INT8U current_direction)
/*****************************************************************************
*   Input    : Switch direction
*   Output   : None
*   Function : Switch color
******************************************************************************/
{
  if(current_direction)                 //currentDirection = 1 - Direction is forward/up
    {
      if(counter >= 7)                  //Reset counter if greater than 7
        counter = 0;
      else
        counter++;
    }
  else                                  //Direction count down
    {
      if(counter <= 0)                  //Reset counter if equal to 0
        counter = 7;
      else
        counter--;
    }

  GPIO_PORTF_DATA_R = (counter << 1);   //read-modify-write operation page 653
}

void SysTick_Handler(void)
/*****************************************************************************
*   Input    : None (ISR)
*   Output   : None
*   Function : SysTick ISR
******************************************************************************/
{
  if ( button_double_click_counter < 200 )                  //Increment button_double_click_counter
    {
      button_double_click_counter++;
    }
  if( button_debounce_counter < 20 )                        //Increment button_debounce_counter
    {
      button_debounce_counter++;
    }
  if ( button_pressed && button_automode_counter <2000 )    //Increment button_automode_counter
    {
      button_automode_counter++;
    }
  if ( automode && automode_counter < 200 )                 //Increment automode_counter
    {
      automode_counter++;
    }
  else if ( automode && automode_counter >= 200 )           //Reset automode_counter and switch color
    {
      automode_counter = 0;
      switch_color( 1 );
    }
}

int main(void)
/*****************************************************************************
*   Input    : None
*   Output   : None
*   Function : MAIN
******************************************************************************/
{
  automode = 0;                         // Ensure that automode is off
  button_pressed = 0;                   // Ensure that button boolean is unpressed
  button_double_click_counter = 200;    // Ensure that timer doesn't count this at start
  button_automode_counter = 2000;       // Ensure that timer doesn't count this at start
  BOOLEAN direction = 1;

  setup_io(); // Setup I/O
  setup_systick(); // Setup timer

  while(1) // Main loop
  {
    if ( !(GPIO_PORTF_DATA_R & 0x10) )          //When button pressed, PF4 = 0.
    {
      button_debounce_counter = 0;
      button_automode_counter = 0;
      if ( button_double_click_counter >= 200 ) //Check for double click
      {
        button_double_click_counter = 0;
      }
      else
      {
        direction ^= 1;                         //Change direction
      }
      button_pressed = 1;
      while ( button_debounce_counter < 20 );   // Delay for debounce (prall)
      if ( !(GPIO_PORTF_DATA_R & 0x10) )        // If button is still pressed check for automode
      {
        while ( !(GPIO_PORTF_DATA_R & 0x10) && button_automode_counter < 2000 );    //Wait for 2 seconds if button is pushed
        if ( button_automode_counter >= 2000 )  // If 2 seconds has passed set automode = 1
        {
          automode_counter = 0;
          automode = 1;
        }
        else
        {
          automode = 0;
        }
      }
      while ( !(GPIO_PORTF_DATA_R & 0x10) );    // Wait for button to be released
      button_pressed = 0;
      button_debounce_counter = 0;
      while ( button_debounce_counter < 20 );   // Delay for debounce (prall)
      if ( !automode )
      {
        switch_color( direction );
      }
    }
  }
}
/****************************** End Of Module *******************************/
